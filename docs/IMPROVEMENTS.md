# 問題点と改善提案ドキュメント

**バージョン**: 1.0.0
**更新日**: 2026-02-10

## 目次

1. [アーキテクチャ・設計](#1-アーキテクチャ設計)
2. [API設計](#2-api設計)
3. [データモデル](#3-データモデル)
4. [テスト戦略](#4-テスト戦略)
5. [プロジェクト管理](#5-プロジェクト管理)
6. [ドキュメント](#6-ドキュメント)
7. [運用・デプロイ](#7-運用デプロイ)
8. [パフォーマンス](#8-パフォーマンス)
9. [セキュリティ](#9-セキュリティ)
10. [Web UI (Phase 3)](#10-web-ui-phase-3)
11. [優先度別サマリー](#11-優先度別サマリー)

---

## 1. アーキテクチャ・設計

### 1.1 PYTHONPATH依存解消

- [ ] **問題**: MARS_for_oidunaがoiduna_coreをPYTHONPATH経由でインポート
  - **現状**: `export PYTHONPATH=...`が必須、開発環境セットアップが煩雑
  - **影響**: IDEの自動補完が効かない、新規開発者の参入障壁が高い
  - **改善案**:
    - **オプションA**: oiduna_coreをpypiパッケージ化（最も推奨）
      - `uv build` → `uv publish` → `uv add oiduna_core`
      - メリット: 標準的なPython依存関係管理
      - デメリット: パッケージメンテナンスの手間
    - **オプションB**: mars_dslにoiduna_coreモデルをコピー
      - メリット: 依存関係なし
      - デメリット: モデル同期の手間、重複コード
    - **オプションC**: モノレポ化（oidunaとMARSを1つのワークスペースに統合）
      - メリット: PYTHONPATH不要、コード共有容易
      - デメリット: リポジトリ構造の大幅変更
  - **優先度**: 高
  - **工数**: オプションA=2日、オプションB=1日、オプションC=3日

### 1.2 モデル重複削減とフィールド名統一

- [ ] **問題**: RuntimeモデルとIRモデルが構造的に類似だが**フィールド名に重大な相違がある**
  - **現状**: `mars_dsl/models.py`と`oiduna_core/ir/*`で同じ構造を定義しているが、フィールド名が異なる
  - **具体例**:
    - RuntimeFx: `delaySend` (キャメルケース) ↔ FxParams: `delay_send` (snake_case)
    - RuntimeTrackFx: `tremolorate` (短縮形) ↔ TrackFxParams: `tremolo_rate` (フル名)、さらに`vowel`, `krush`, `kcutoff`, `triode`フィールドが欠落
    - RuntimeMixerLineFx: `room` (prefix削除) ↔ MixerLineFx: `reverb_room` (prefix付き)
    - RuntimeTrack: `sound` ↔ Track: `params`
    - RuntimeEvent: `nudge`欠落 ↔ Event: `nudge`あり
  - **影響**:
    - ドキュメントの信頼性低下（「100%同一」は誤り）
    - 変換ロジックの複雑化（`mars_compiler/model_converter.py`）
    - 変更時の同期漏れリスク、コード重複（約1500行）
  - **改善案**:
    - **オプションA**: フィールド名を統一してから共通パッケージ化（推奨）
      - mars_dslのフィールド名をoiduna_coreに合わせてsnake_caseに統一
      - その後`oiduna_common`パッケージを作成し、両方からインポート
      - メリット: 単一真実源（Single Source of Truth）、命名規則の統一
      - デメリット: DSL文法の変更が必要、既存コードの互換性
    - **オプションB**: 明示的な変換マッピングテーブルをコードに追加
      - フィールド名の対応関係を辞書で定義
      - メリット: 既存の互換性維持
      - デメリット: 変換ロジックの複雑性継続
    - **オプションC**: 現状維持（ドキュメントで相違を明示）
      - ドキュメント（03_データモデルリファレンス.md）でフィールド名対応表を提供
      - メリット: 変更不要
      - デメリット: 同期リスクの継続、複雑性の維持
  - **優先度**: 高（Single Source of Truth違反のため）
  - **工数**: オプションA=5日、オプションB=2日、オプションC=1日（ドキュメント更新のみ）

### 1.3 3層IR検証ツール

- [ ] **問題**: 3層IRの整合性検証が手動
  - **現状**: CompiledSessionのバリデーションがない
  - **影響**: 不正なIRでもコンパイルが通る可能性
  - **改善案**:
    - **オプションA**: Pydanticベースのバリデーター実装
      - すべてのIRモデルをPydantic BaseModelに変更
      - メリット: 自動バリデーション、型安全性向上
      - デメリット: 大規模リファクタリング（全dataclassをPydanticに変更）
    - **オプションB**: 専用バリデーター関数の実装
      - `validate_compiled_session(session: CompiledSession) -> ValidationResult`
      - チェック項目: track_id整合性、sequenceの存在確認、mixer_lineの参照整合性等
      - メリット: 既存コード変更最小
      - デメリット: バリデーションロジックの手動実装
    - **オプションC**: テストスイートでのカバレッジ向上
      - 不正なIRパターンのテストケース追加
      - メリット: 実装不要
      - デメリット: 実行時エラーの可能性
  - **優先度**: 低
  - **工数**: オプションA=5日、オプションB=2日、オプションC=1日

---

## 2. API設計

### 2.1 エンドポイント一貫性

- [ ] **問題**: レスポンス形式の不統一
  - **現状**:
    - `/compile` → `{"success": true, "data": {...}, "warnings": []}`
    - `/project` → `{"is_open": true, "path": "...", ...}`
    - `/health` → `{"status": "ok"}`
  - **影響**: クライアント実装の複雑化
  - **改善案**:
    - **オプションA**: 統一レスポンスエンベロープの導入（推奨）
      ```json
      {
        "ok": true,
        "data": {...},
        "error": null,
        "warnings": []
      }
      ```
      - すべてのエンドポイントで共通
      - メリット: 一貫性、エラーハンドリング統一
      - デメリット: 既存クライアントの修正必要
    - **オプションB**: OpenAPI仕様の厳密化
      - すべてのレスポンスをPydanticモデルで定義
      - メリット: 自動バリデーション、ドキュメント自動生成
      - デメリット: 実装工数
    - **オプションC**: 現状維持
  - **優先度**: 中
  - **工数**: オプションA=2日、オプションB=3日、オプションC=0日

### 2.2 エラーハンドリング統一

- [ ] **問題**: エラーレスポンスの形式が統一されていない
  - **現状**: HTTPステータスコードとボディの対応が曖昧
  - **影響**: クライアントのエラーハンドリングが複雑
  - **改善案**:
    - **オプションA**: RFC 7807 Problem Details準拠（推奨）
      ```json
      {
        "type": "https://example.com/probs/out-of-credit",
        "title": "You do not have enough credit.",
        "status": 400,
        "detail": "Your current balance is 30, but that costs 50.",
        "instance": "/account/12345/msgs/abc"
      }
      ```
      - メリット: 標準仕様、デバッグ容易
      - デメリット: 既存実装の変更
    - **オプションB**: 独自エラー体系の確立
      - エラーコード体系（E001-E999）
      - エラーメッセージの国際化対応
      - メリット: 柔軟性
      - デメリット: メンテナンスコスト
    - **オプションC**: FastAPIデフォルトエラーの活用
      - メリット: 実装不要
      - デメリット: カスタマイズ性低い
  - **優先度**: 中
  - **工数**: オプションA=1.5日、オプションB=3日、オプションC=0日

### 2.3 認証・認可実装

- [ ] **問題**: 認証機構が存在しない
  - **現状**: すべてのリクエストを無条件で受け付ける
  - **影響**: 本番環境での不正アクセスリスク
  - **改善案**:
    - **オプションA**: JWT（JSON Web Token）の実装（推奨）
      - `/auth/login` でトークン発行
      - すべてのエンドポイントで`Authorization: Bearer <token>`チェック
      - メリット: ステートレス、標準的
      - デメリット: ユーザー管理システムの実装が必要
    - **オプションB**: APIキー認証
      - `X-API-Key` ヘッダーでのシンプル認証
      - メリット: 実装簡単
      - デメリット: 細かい権限管理不可
    - **オプションC**: OAuth 2.0
      - 外部IdP（Keycloak、Auth0等）連携
      - メリット: エンタープライズグレード
      - デメリット: 複雑、外部依存
  - **優先度**: 高
  - **工数**: オプションA=3日、オプションB=1日、オプションC=5日

---

## 3. データモデル

### 3.1 型安全性の完全確保

- [x] **問題**: mypy型チェックエラー（完了確認）
  - **現状**: ✅ 完了（REFACTORING_REPORT.mdで確認済み）
  - **状態**: mypy エラー0件、99/99テストパス
  - **達成事項**:
    - HttpUrl型の`type: ignore`適切使用
    - Optional vs | None の統一
    - トップレベルimport整理
  - **優先度**: ✅ 完了
  - **工数**: 完了

### 3.2 Pydanticバリデーションの拡充

- [x] **問題**: バリデーションルールの不足（完了確認）
  - **現状**: ✅ 完了（validation-improvements.mdで確認済み）
  - **達成事項**:
    - hexカラーバリデーション（正規表現パターン）
    - URL形式バリデーション（HttpUrl型）
    - timeout範囲バリデーション（Field constraints）
  - **追加検討事項**:
    - [ ] BPM範囲バリデーション（20-300推奨）
    - [ ] ファイル名バリデーション（特殊文字禁止）
    - [ ] DSLコードサイズ制限（100KB推奨）
  - **優先度**: 低
  - **工数**: 0.5日

### 3.3 シリアライゼーション最適化

- [ ] **問題**: JSON変換の非効率
  - **現状**: `to_dict()`を手動実装、再帰的な辞書変換
  - **影響**: 大規模セッションでのシリアライズ時間増加（~100ms）
  - **改善案**:
    - **オプションA**: Pydantic JSON Schema活用（推奨）
      - すべてのモデルをPydantic BaseModelに変更
      - `model_dump_json()`で高速シリアライズ
      - メリット: 高速（C拡張）、標準的
      - デメリット: 大規模リファクタリング
    - **オプションB**: orjson採用
      - `import orjson; orjson.dumps(obj)`
      - メリット: 最速のJSONライブラリ、既存コード変更少
      - デメリット: C依存、dataclassサポート要調整
    - **オプションC**: 現状維持 + キャッシング
      - シリアライズ結果をLRUキャッシュ
      - メリット: 実装簡単
      - デメリット: メモリ使用量増加
  - **優先度**: 低
  - **工数**: オプションA=5日、オプションB=1日、オプションC=0.5日

---

## 4. テスト戦略

### 4.1 Integration Testsの拡充

- [ ] **問題**: 統合テストのカバレッジ不足
  - **現状**: 2テストのみ（Oiduna起動が必要なためSKIP）
  - **影響**: E2Eシナリオの検証不足
  - **改善案**:
    - **オプションA**: テスト用Oidunaモックサーバーの実装（推奨）
      - `tests/fixtures/oiduna_mock.py`
      - FastAPIでミニマルなOiduna互換サーバーを実装
      - メリット: Oiduna起動不要、高速実行
      - デメリット: モック実装の手間
    - **オプションB**: Docker Composeテスト環境
      - `docker-compose.test.yml`
      - Oiduna + MARS APIをコンテナ起動
      - メリット: 実環境に近い
      - デメリット: 実行時間長い、Docker必須
    - **オプションC**: CI/CDでのみ実行
      - GitHub Actionsでoidunaを自動起動
      - メリット: ローカル環境への影響なし
      - デメリット: ローカルでの統合テスト困難
  - **優先度**: 高
  - **工数**: オプションA=2日、オプションB=1.5日、オプションC=1日

### 4.2 Performance Testsの追加

- [ ] **問題**: パフォーマンステストがない
  - **現状**: 負荷テスト、ベンチマークの仕組みなし
  - **影響**: パフォーマンス劣化の検知遅れ
  - **改善案**:
    - **オプションA**: pytest-benchmarkの導入（推奨）
      ```python
      def test_compile_performance(benchmark):
          result = benchmark(compiler.compile_v5, dsl_code)
          assert result is not None
      ```
      - メリット: 統計的分析、CI統合容易
      - デメリット: テスト実行時間増加
    - **オプションB**: Locustによる負荷テスト
      - `locustfile.py`でHTTP負荷シナリオ定義
      - メリット: リアルな負荷テスト
      - デメリット: 別ツール学習コスト
    - **オプションC**: 手動ベンチマークスクリプト
      - `scripts/benchmark.py`
      - メリット: 柔軟性
      - デメリット: CI統合困難
  - **優先度**: 中
  - **工数**: オプションA=1.5日、オプションB=2日、オプションC=0.5日

### 4.3 oidunaテストカバレッジ計測

- [ ] **問題**: oidunaのテストカバレッジが不明
  - **現状**: テスト実行状況が未確認
  - **影響**: oiduna側のバグリスク
  - **改善案**:
    - **オプションA**: pytest-cov導入（推奨）
      ```bash
      uv run pytest tests/ -v \
        --cov=oiduna_core \
        --cov=oiduna_loop \
        --cov=oiduna_api \
        --cov-report=html
      ```
      - メリット: 詳細なカバレッジレポート
      - デメリット: なし
    - **オプションB**: coverage.py直接使用
      - メリット: 柔軟なカスタマイズ
      - デメリット: 設定が煩雑
  - **優先度**: 中
  - **工数**: オプションA=0.5日、オプションB=1日

---

## 5. プロジェクト管理

### 5.1 バージョン管理機能

- [ ] **問題**: クリップのバージョン履歴がない
  - **現状**: 上書き保存のみ、変更履歴なし
  - **影響**: 誤編集時のロールバック不可
  - **改善案**:
    - **オプションA**: Gitベースのバージョン管理（推奨）
      - プロジェクトディレクトリを自動的にGitリポジトリ化
      - クリップ保存時に自動コミット
      - `/clips/{name}/history` でバージョン一覧取得
      - メリット: 標準的、差分確認容易
      - デメリット: Git依存
    - **オプションB**: 独自バージョンテーブル実装
      - SQLite or JSON形式でバージョン履歴保存
      - メリット: Git不要
      - デメリット: 実装コスト、ディスク使用量増加
    - **オプションC**: タイムスタンプ付きバックアップ
      - `clips/{name}.json.2026-02-10T10-00-00.bak`
      - メリット: 実装簡単
      - デメリット: ファイル数増加、差分確認困難
  - **優先度**: 低
  - **工数**: オプションA=3日、オプションB=4日、オプションC=1日

### 5.2 複数プロジェクト同時オープン

- [ ] **問題**: 1つのプロジェクトしか開けない
  - **現状**: グローバルな`_current_project`変数で管理
  - **影響**: ライブパフォーマンス時の柔軟性低下
  - **改善案**:
    - **オプションA**: セッションベース管理（推奨）
      - セッションIDをクライアントに発行
      - `X-Session-ID` ヘッダーで識別
      - メリット: 複数クライアント対応
      - デメリット: セッション管理の実装
    - **オプションB**: URLパスベース
      - `/projects/{project_id}/songs/...`
      - メリット: RESTful
      - デメリット: 既存API構造の大幅変更
    - **オプションC**: プロセス分離
      - プロジェクトごとにMARSインスタンス起動
      - メリット: 隔離性高い
      - デメリット: リソース消費大
  - **優先度**: 低
  - **工数**: オプションA=3日、オプションB=5日、オプションC=2日

### 5.3 プロジェクトエクスポート・インポート

- [ ] **問題**: プロジェクトの移行・共有機能なし
  - **現状**: ファイルシステム直接コピーのみ
  - **影響**: チーム間でのプロジェクト共有困難
  - **改善案**:
    - **オプションA**: ZIP形式エクスポート（推奨）
      - `/project/export` → project_name.zip
      - `/project/import` ← ZIPアップロード
      - メリット: 標準的、圧縮効率良い
      - デメリット: サーバー側での圧縮処理負荷
    - **オプションB**: JSON単一ファイル
      - プロジェクト全体を1つのJSONに集約
      - メリット: 実装簡単、テキストベース
      - デメリット: 大規模プロジェクトでファイルサイズ増大
    - **オプションC**: Git bundleフォーマット
      - `git bundle create project.bundle --all`
      - メリット: バージョン履歴も含まれる
      - デメリット: Git必須、一般ユーザーに不向き
  - **優先度**: 低
  - **工数**: オプションA=2日、オプションB=1日、オプションC=1.5日

---

## 6. ドキュメント

### 6.1 日本語ドキュメントの充実

- [x] **問題**: 日本語ドキュメント不足（完了確認）
  - **現状**: ✅ 完了（今回の認識合わせドキュメント群で対応）
  - **達成事項**:
    - システム全体像ドキュメント
    - 現状分析ドキュメント
    - 問題点と改善提案ドキュメント
    - データモデルリファレンス
  - **優先度**: ✅ 完了
  - **工数**: 完了

### 6.2 APIリファレンスの充実

- [ ] **問題**: OpenAPIスキーマの説明不足
  - **現状**: FastAPIの自動生成スキーマのみ、例が少ない
  - **影響**: API利用者の学習コスト増加
  - **改善案**:
    - **オプションA**: OpenAPI Examples拡充（推奨）
      ```python
      @app.post("/compile",
          openapi_extra={
              "examples": {
                  "basic": {
                      "summary": "基本パターン",
                      "value": {"dsl": "..."}
                  }
              }
          })
      ```
      - メリット: Swagger UIに表示、標準的
      - デメリット: 各エンドポイントへの追記が必要
    - **オプションB**: 別途API仕様書作成
      - Markdownで詳細仕様書
      - メリット: 柔軟性高い
      - デメリット: OpenAPIスキーマと同期の手間
    - **オプションC**: Postmanコレクション提供
      - `.postman_collection.json`
      - メリット: インタラクティブなテスト可能
      - デメリット: メンテナンスコスト
  - **優先度**: 中
  - **工数**: オプションA=1.5日、オプションB=3日、オプションC=1日

### 6.3 トラブルシューティングガイド

- [ ] **問題**: よくある問題の対処法が不明瞭
  - **現状**: READMEに簡単な記載のみ
  - **影響**: ユーザーサポートコスト増加
  - **改善案**:
    - **オプションA**: FAQ形式ドキュメント作成（推奨）
      - `docs/troubleshooting.md`
      - Q&A形式で主要な問題と解決策を記載
      - カテゴリ: インストール、起動、コンパイルエラー、接続エラー等
      - メリット: 検索性良い
      - デメリット: 定期更新が必要
    - **オプションB**: GitHub Discussions活用
      - FAQ専用スレッド作成
      - メリット: コミュニティからのフィードバック得やすい
      - デメリット: 体系化しづらい
    - **オプションC**: エラーメッセージへのURL埋め込み
      - エラー発生時に対応ドキュメントURLを表示
      - メリット: 問題解決への最短経路
      - デメリット: エラーメッセージ変更の手間
  - **優先度**: 高
  - **工数**: オプションA=2日、オプションB=0.5日、オプションC=2日

---

## 7. 運用・デプロイ

### 7.1 Docker Compose統合

- [ ] **問題**: oidunaとMARSの個別起動が煩雑
  - **現状**: 各サービスを手動で起動
  - **影響**: 開発環境セットアップの手間
  - **改善案**:
    - **オプションA**: docker-compose.yml作成（推奨）
      ```yaml
      services:
        oiduna:
          build: ./oiduna
          ports: ["8000:8000"]
        mars:
          build: ./MARS_for_oiduna
          ports: ["3000:3000"]
          depends_on: [oiduna]
      ```
      - メリット: 一発起動、依存関係明示
      - デメリット: SuperColliderのDocker化が困難
    - **オプションB**: tmux統合スクリプト拡充
      - `scripts/start_all.sh`の改善
      - メリット: Docker不要
      - デメリット: クロスプラットフォーム性低い
    - **オプションC**: systemdサービス化
      - `/etc/systemd/system/oiduna.service`
      - メリット: 自動起動、ログ管理統一
      - デメリット: Linux専用
  - **優先度**: 中
  - **工数**: オプションA=2日、オプションB=0.5日、オプションC=1日

### 7.2 ヘルスチェック機能の拡充

- [x] **問題**: 基本的なヘルスチェックのみ（完了確認）
  - **現状**: ✅ `/health`エンドポイント実装済み
  - **追加検討事項**:
    - [ ] 依存サービス（SuperCollider、MIDI）の生存確認
    - [ ] レディネスプローブ（起動完了確認）とライブネスプローブ（稼働確認）の分離
    - [ ] メトリクス露出（/metrics、Prometheus形式）
  - **優先度**: 中
  - **工数**: 1日

### 7.3 ログ・モニタリング

- [ ] **問題**: 構造化ログがない
  - **現状**: printデバッグ、標準ログ出力のみ
  - **影響**: 本番環境でのトラブルシュート困難
  - **改善案**:
    - **オプションA**: structlog導入（推奨）
      ```python
      logger.info("pattern_compiled",
                  track_count=len(session.tracks),
                  bpm=session.environment.bpm)
      ```
      - JSON形式ログ出力
      - メリット: 解析ツール連携容易、検索性高い
      - デメリット: ログフォーマット変更
    - **オプションB**: OpenTelemetry対応
      - トレーシング、メトリクス、ログの統合
      - メリット: エンタープライズグレード
      - デメリット: 複雑、外部依存
    - **オプションC**: Sentry統合
      - エラートラッキング専用
      - メリット: エラー通知、スタックトレース保存
      - デメリット: 外部サービス依存
  - **優先度**: 中
  - **工数**: オプションA=1.5日、オプションB=4日、オプションC=1日

---

## 8. パフォーマンス

### 8.1 コンパイルキャッシュ

- [ ] **問題**: 同じDSLコードを毎回再コンパイル
  - **現状**: コンパイル結果のキャッシュなし
  - **影響**: 不要なCPU消費、レスポンス遅延
  - **改善案**:
    - **オプションA**: LRUキャッシュ + DSLハッシュ（推奨）
      ```python
      @lru_cache(maxsize=100)
      def compile_cached(dsl_hash: str, dsl: str) -> CompiledSession:
          return compiler.compile_v5(dsl)

      dsl_hash = hashlib.sha256(dsl.encode()).hexdigest()[:16]
      result = compile_cached(dsl_hash, dsl)
      ```
      - メリット: 実装簡単、メモリ効率良い
      - デメリット: サーバー再起動でキャッシュクリア
    - **オプションB**: Redisキャッシュ
      - 分散環境対応、永続化可能
      - メリット: 複数インスタンス間で共有
      - デメリット: Redis依存、複雑化
    - **オプションC**: ファイルベースキャッシュ
      - `.cache/compiled/{hash}.json`
      - メリット: 再起動後も有効
      - デメリット: ディスクI/O増加
  - **優先度**: 中
  - **工数**: オプションA=1日、オプションB=2日、オプションC=1.5日

### 8.2 ループエンジン最適化

- [ ] **問題**: 大規模パターンでのCPU使用率増加
  - **現状**: EventSequenceのルックアップは最適化済み（O(1)）だが、モジュレーション計算は未最適化
  - **影響**: 20トラック以上でCPU使用率30-40%
  - **改善案**:
    - **オプションA**: モジュレーション計算のベクトル化（推奨）
      - NumPy使用、SIMD命令活用
      - メリット: 高速化（3-5倍）
      - デメリット: NumPy依存、コード複雑化
    - **オプションB**: Cython/Rustによる再実装
      - ホットスポットをネイティブコード化
      - メリット: 最大速度（5-10倍）
      - デメリット: ビルド複雑化、メンテナンスコスト
    - **オプションC**: マルチプロセス化
      - トラックごとに並列処理
      - メリット: マルチコアCPU活用
      - デメリット: プロセス間通信オーバーヘッド
  - **優先度**: 低
  - **工数**: オプションA=3日、オプションB=7日、オプションC=2日

---

## 9. セキュリティ

### 9.1 入力バリデーションの強化

- [x] **問題**: 基本的なバリデーションのみ（完了確認）
  - **現状**: ✅ Pydanticバリデーション実装済み
  - **追加検討事項**:
    - [ ] DSLコードサイズ制限（DoS対策）
    - [ ] ファイル名のサニタイゼーション（パストラバーサル対策）
    - [ ] 正規表現DoS（ReDoS）対策
  - **優先度**: 中
  - **工数**: 1日

### 9.2 CORS設定の厳格化

- [ ] **問題**: すべてのオリジンを許可
  - **現状**: `allow_origins=["*"]`
  - **影響**: 本番環境でのセキュリティリスク
  - **改善案**:
    - **オプションA**: 環境変数ベースの許可リスト（推奨）
      ```python
      allowed_origins = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000").split(",")
      app.add_middleware(CORSMiddleware, allow_origins=allowed_origins)
      ```
      - メリット: 環境ごとに柔軟に設定
      - デメリット: なし
    - **オプションB**: 設定ファイルでの管理
      - `config/cors.yaml`
      - メリット: 複雑な設定に対応
      - デメリット: ファイル管理の手間
  - **優先度**: 高
  - **工数**: オプションA=0.5日、オプションB=1日

### 9.3 ファイルアップロードセキュリティ

- [ ] **問題**: `/assets`エンドポイントの検証不足
  - **現状**: サイズ制限のみ、拡張子・内容チェックなし
  - **影響**: 悪意のあるファイルアップロード可能
  - **改善案**:
    - **オプションA**: ファイルタイプ検証（推奨）
      ```python
      import magic
      mime = magic.from_buffer(file_content, mime=True)
      if mime not in ALLOWED_MIMES:
          raise HTTPException(415, "Unsupported file type")
      ```
      - メリット: 拡張子偽装を防ぐ
      - デメリット: libmagic依存
    - **オプションB**: 拡張子ホワイトリスト
      - `.wav`, `.flac`, `.aiff`, `.scsyndef`のみ許可
      - メリット: 実装簡単
      - デメリット: 偽装に弱い
    - **オプションC**: ウイルススキャン統合
      - ClamAV等でスキャン
      - メリット: マルウェア検出
      - デメリット: 処理時間増加、外部依存
  - **優先度**: 中
  - **工数**: オプションA=1日、オプションB=0.5日、オプションC=2日

---

## 10. Web UI (Phase 3)

### 10.1 Monaco Editor統合

- [ ] **問題**: DSL編集にIDEが必要
  - **現状**: テキストエディタまたはcurlでのDSL編集
  - **影響**: ユーザー体験の低下
  - **改善案**:
    - **オプションA**: React + Monaco Editor SPA（推奨）
      - `mars_ui/` 新規パッケージ作成
      - Vite + React + Monaco Editor
      - MARS APIと通信
      - メリット: 最新技術、拡張性高い
      - デメリット: 開発工数大
    - **オプションB**: FastAPI Templatesでのシンプル実装
      - Jinja2テンプレート + vanilla JS
      - メリット: 実装簡単、依存少ない
      - デメリット: リッチなUIは困難
  - **優先度**: 中
  - **工数**: オプションA=10日、オプションB=5日

### 10.2 MARS DSL Language Server

- [ ] **問題**: DSL編集時の入力補完・エラーチェックなし
  - **現状**: 構文エラーはコンパイル時のみ検出
  - **影響**: 開発効率低下
  - **改善案**:
    - **オプションA**: LSP (Language Server Protocol)実装（推奨）
      - `mars_lsp/` パッケージ作成
      - pygls（Python LSPライブラリ）使用
      - Monaco Editorと連携
      - 機能: 構文ハイライト、補完、エラー表示、定義ジャンプ
      - メリット: VSCode等でも使用可能
      - デメリット: 実装コスト大
    - **オプションB**: 簡易的な補完機能
      - キーワードリストベースの補完
      - メリット: 実装簡単
      - デメリット: 機能限定的
  - **優先度**: 低
  - **工数**: オプションA=7日、オプションB=2日

---

## 11. 優先度別サマリー

### 11.1 高優先度（本番環境必須）

| # | 項目 | 工数 | カテゴリ |
|---|------|------|----------|
| 1 | PYTHONPATH依存解消 | 2日 | アーキテクチャ |
| 2 | 認証・認可実装（JWT） | 3日 | API設計 |
| 3 | CORS設定厳格化 | 0.5日 | セキュリティ |
| 4 | Integration Tests拡充 | 2日 | テスト |
| 5 | トラブルシューティングガイド | 2日 | ドキュメント |

**合計**: 9.5日

### 11.2 中優先度（品質向上）

| # | 項目 | 工数 | カテゴリ |
|---|------|------|----------|
| 1 | モデル重複削減 | 3日 | アーキテクチャ |
| 2 | エンドポイント一貫性 | 2日 | API設計 |
| 3 | エラーハンドリング統一 | 1.5日 | API設計 |
| 4 | Performance Tests追加 | 1.5日 | テスト |
| 5 | oidunaテストカバレッジ | 0.5日 | テスト |
| 6 | APIリファレンス拡充 | 1.5日 | ドキュメント |
| 7 | Docker Compose統合 | 2日 | 運用 |
| 8 | ヘルスチェック拡充 | 1日 | 運用 |
| 9 | ログ・モニタリング | 1.5日 | 運用 |
| 10 | コンパイルキャッシュ | 1日 | パフォーマンス |
| 11 | 入力バリデーション強化 | 1日 | セキュリティ |
| 12 | ファイルアップロードセキュリティ | 1日 | セキュリティ |
| 13 | Monaco Editor統合 | 10日 | Web UI |

**合計**: 27.5日

### 11.3 低優先度（機能拡張）

| # | 項目 | 工数 | カテゴリ |
|---|------|------|----------|
| 1 | 3層IR検証ツール | 2日 | アーキテクチャ |
| 2 | シリアライゼーション最適化 | 1日 | データモデル |
| 3 | バージョン管理機能 | 3日 | プロジェクト管理 |
| 4 | 複数プロジェクト同時オープン | 3日 | プロジェクト管理 |
| 5 | プロジェクトエクスポート | 2日 | プロジェクト管理 |
| 6 | ループエンジン最適化 | 3日 | パフォーマンス |
| 7 | DSL Language Server | 7日 | Web UI |

**合計**: 21日

### 11.4 総工数サマリー

| 優先度 | 項目数 | 工数 |
|--------|--------|------|
| **高** | 5 | 9.5日 |
| **中** | 13 | 27.5日 |
| **低** | 7 | 21日 |
| **合計** | **25** | **58日** |

**推奨実装順序**:
1. 第1フェーズ（2週間）: 高優先度すべて
2. 第2フェーズ（4週間）: 中優先度の運用・セキュリティ項目
3. 第3フェーズ（6週間）: Web UI + 残りの中優先度
4. 第4フェーズ（3週間）: 低優先度の機能拡張

---

## 関連ドキュメント

- [システム全体像](00_システム全体像.md)
- [現状分析](01_現状分析.md)
- [データモデルリファレンス](03_データモデルリファレンス.md)

---

**バージョン**: 1.0.0
**更新日**: 2026-02-10
**作成者**: Claude Code
